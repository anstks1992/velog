<h2 id="04변수">04.변수</h2>
<hr />
<h3 id="41-변수란-무엇인가">4.1 변수란 무엇인가?</h3>
<h5 id="예를들어-1020이라는-예제가-있다-컴퓨터에서-예제-수식을-계산할-시-숫자-값-10과-20은-메모리-상의-임의의-위치메모리-주소에-이진수로-기억-되고-cpu는-이-값을-읽어들여-연산을-수행한다-문제는-1020을-해서-나온-30이라는-연산결과를-한번이-아닌-재사용-할려면-30이-저장된-메모리-공간에-직접-접근을-해야되는데-이는-시스템을-멈추게-하는-치명적인-결과를-발생-시킬-수-있다">예를들어 10+20이라는 예제가 있다. 컴퓨터에서 예제 수식을 계산할 시 숫자 값 10과 20은 메모리 상의 임의의 위치(메모리 주소)에 이진수로 기억 되고 cpu는 이 값을 읽어들여 연산을 수행한다. 문제는 10+20을 해서 나온 30이라는 연산결과를 한번이 아닌 재사용 할려면 30이 저장된 메모리 공간에 직접 접근을 해야되는데 이는 시스템을 멈추게 하는 치명적인 결과를 발생 시킬 수 있다.</h5>
<h5 id="따라서-우리는-기억하고-싶은-값을-메모리에-저장하고저장된-값을-재사용하기-위한-메커니즘이-필요한데-그것이-변수이다">따라서 우리는 기억하고 싶은 값을 메모리에 저장하고,저장된 값을 재사용하기 위한 메커니즘이 필요한데 그것이 변수이다.</h5>
<blockquote>
<h5 id="변수는-하나의-값을-저장하기-위해값의-위치를-알기위해-확보한-메모리-공간-자체-또는-그-메모리-공간을-식별하기-위해-붙인-이름을-말한다">변수는 하나의 값을 저장하기 위해(값의 위치를 알기위해) 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다</h5>
</blockquote>
<h3 id="42-식별자">4.2 식별자</h3>
<blockquote>
<p>식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름이다</p>
</blockquote>
<pre><code>const sum = 10 + 20 // sum은 식별자</code></pre><h5 id="여기서-식별자-sum은-값-30을-식별할-수-있지만-값을-기억하고-있는게-아니라-메모리-주소를-기억하고-있다-즉-값을-식별하는-게-아닌-식별자가-기억하고-있는-메모리-주소를-통해-메모리-공간에-저장된-값에-접근할-수-있다는-의미다">여기서 식별자 sum은 값 30을 식별할 수 있지만 값을 기억하고 있는게 아니라 메모리 주소를 기억하고 있다. 즉 값을 식별하는 게 아닌 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미다</h5>
<h5 id="식별자라는-용어는-단순히-변수이름에만-국한된-게-아니라-함수클래스등의-이름도-모두-식별자이다">식별자라는 용어는 단순히 변수이름에만 국한된 게 아니라 함수,클래스등의 이름도 모두 식별자이다</h5>
<h3 id="43-변수-선언">4.3 변수 선언</h3>
<h5 id="변수선언이란-값을-저장하기-위한-메모리-공간을-확보하고-변수-이름과-확보된-메모리-공간의-주소를-연결해서-값을-지정할-수-있게-준비하는-것인데-변수를-선언할-때는-varletconst-를-사용한다">변수선언이란 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 지정할 수 있게 준비하는 것인데 변수를 선언할 때는 <em>var,let,const</em> 를 사용한다</h5>
<pre><code>var score // undefined</code></pre><h5 id="var-score는-선언-단계를-통해-변수이름-score를-등록하고초기화-단계를-통해-score-변수에-암묵적으로-undefined를-할당해-초기화-한다-이러한-초기화-단계를-거치지-않으면-메모리-공간에-이전에-다른-애플리케이션에서-사용했던-쓰레기-값이-남아-있을-수-있지만-var-키워드는-암묵적으로-안전하게-이를-초기화-해준다">var score는 선언 단계를 통해 변수이름 score를 등록하고,초기화 단계를 통해 score 변수에 암묵적으로 undefined를 할당해 초기화 한다. 이러한 초기화 단계를 거치지 않으면 메모리 공간에 이전에 다른 애플리케이션에서 사용했던 쓰레기 값이 남아 있을 수 있지만 var 키워드는 암묵적으로 안전하게 이를 초기화 해준다.</h5>
<h3 id="44-변수-선언의-실행-시점과-변수-호이스팅">4.4 변수 선언의 실행 시점과 변수 호이스팅</h3>
<pre><code>console.log(score) // undefined
var score // 변수 선언문</code></pre><h5 id="변수-선언문-보다-참조하는-코드가-앞에-있어-참조에러가-발생할-것-같지만-undefined가-발생한다-자바스크립트-코드는-주로-인터프리터에-위해-위에서부터-순차적으로-진행-되지만-변수-선언이-소스코드가-한-줄씩-순차적으로-실행되는-시점-즉-런타임이-아니라-그-이전-단계에서-먼저-실행되기-때문에--참조에러가-발생하지-않는다">변수 선언문 보다 참조하는 코드가 앞에 있어 참조에러가 발생할 것 같지만 undefined가 발생한다. 자바스크립트 코드는 주로 인터프리터에 위해 위에서부터 순차적으로 진행 되지만 <em>변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문에</em>  참조에러가 발생하지 않는다</h5>
<h5 id="자바스크립트-엔진은-소스코드를-순차적으로-실행하기에-앞서-평가-과정을-거치는데-이러한-평가-과정에서-변수선언을-포함한-모든-선언문변수-선언문-함수-선언문을-소스코드에서-찾아내-먼저-실행한다">자바스크립트 엔진은 소스코드를 순차적으로 실행하기에 앞서 평가 과정을 거치는데 이러한 평가 과정에서 변수선언을 포함한 모든 선언문(변수 선언문, 함수 선언문)을 소스코드에서 찾아내 먼저 실행한다</h5>
<h5 id="즉-변수선언이-어디에-위치하든-다른-코드보다-먼저-실행된다">즉, 변수선언이 어디에 위치하든 다른 코드보다 먼저 실행된다</h5>
<blockquote>
<p>변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 '변수 호이스팅'이라 한다.</p>
</blockquote>
<h3 id="45-값의-할당">4.5 값의 할당</h3>
<pre><code>console.log(score) //undefined

var score // 1)변수선언
score = 80;// 2)값의 할당

console.log(score) //80</code></pre><h5 id="변수-선언1은-런타임-이전에-실행되고-값의-할당2은-런타임에-실행된다-score에-값을-할당하는-시점2에는-이미-변수-선언1이-완료된-상태이며-이미-undefinde로-초기화-되어있다-따라서-score에-변수를-값을-할당하면-score-변수의-값은-undefined에서-새롭게-할당한-값-80으로-변경재할당된다-이때-undefine가-있는-메모리공간을-지우고-할당하는-게-아닌-새로운-메모리-공간을-확보하고-그곳에-값-80을-할당하는-한다는-점은-주의하자">변수 선언(1)은 런타임 이전에 실행되고 값의 할당(2)은 런타임에 실행된다. score에 값을 할당하는 시점(2)에는 이미 변수 선언(1)이 완료된 상태이며, 이미 undefinde로 초기화 되어있다. 따라서 score에 변수를 값을 할당하면 score 변수의 값은 undefined에서 새롭게 할당한 값 80으로 변경(재할당)된다. 이때 undefine가 있는 메모리공간을 지우고 할당하는 게 아닌 새로운 메모리 공간을 확보하고 그곳에 값 80을 할당하는 한다는 점은 주의하자</h5>
<h3 id="45-값의-재할당">4.5 값의 재할당</h3>
<pre><code>var score = 80; //변수 선언과 값의 할당
score = 90; //값의 재할당</code></pre><h5 id="var-변수는-현재-변수에-저장된-값을-버리고-새로운-값을-저장하는-재할당이-가능하다">var 변수는 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 재할당이 가능하다</h5>
<h5 id="이와-반대로-값을-재할당-할-수-없어서-변수에-저장된-값을-변경할수-없으면-변수가-아니라-상수constant라고-한다">이와 반대로 값을 재할당 할 수 없어서 변수에 저장된 값을 변경할수 없으면 변수가 아니라 상수(constant)라고 한다.</h5>
<h3 id="46-식별자-네이밍-규칙">4.6 식별자 네이밍 규칙</h3>
<blockquote>
<p>1.식별자는 특수문자를 제외한 문자,순자,언더스코어(<em>),달러기호를 포함 가능
2.단 식별자는 특수문자를 제외한 문자,언더스코어(</em>),달러기호로 시작해야 하며 숫자로 시작하면 안된다.
3. 예약어는 식별자로 사용 금지
ex) await, break, class, case, catch, const, if, else, default, false, export, if …)</p>
</blockquote>
<h5 id="가능한-변수-이름-식별자사용은-되지만-권장x">가능한 변수 이름 식별자(사용은 되지만 권장x)</h5>
<pre><code>var person,$elem,_name,first_name,val1;//쉼표로 구분해서 여러개를 한번에 선언

var 이름, なまえ; //알파벳 이외 유니코드 문자 사용</code></pre><h5 id="사용이-불가능한-식별자">사용이 불가능한 식별자</h5>
<pre><code>var first-name; // SyntaxError: Unexpected token –
var 1st;        // SyntaxError: Invalid or unexpected token
var this;       // SyntaxError: Unexpected token this</code></pre><h5 id="변수-식별자는-대소문자를-구분">변수 식별자는 대소문자를 구분</h5>
<pre><code>var firstname;
var firstName;
var FIRSTNAME;</code></pre><h5 id="자주사용되는-네이밍-컨벤션">자주사용되는 네이밍 컨벤션</h5>
<pre><code>// 카멜 케이스 (camelCase)
var firstName; //변수와 함수에 자주 쓰임

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName; //생성자함수, 클래스 이름에 자주 쓰임

// 헝가리언 케이스 (typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블</code></pre><h3 id="📚-기타-cs-지식">📚 기타 CS 지식</h3>
<h5 id="가비지-콜렉터">가비지 콜렉터</h5>
<blockquote>
<p>애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리(어떤 식별자도 참조하지 않는 메모리 공간)를 해체하는 기능</p>
</blockquote>
<h5 id="언매지니드-언어-vs-매니지드-언어">언매지니드 언어 vs 매니지드 언어</h5>
<blockquote>
<p>언매지니드 언어:
c 언어 같은 언매지니드 언어는 개발자가 명시적으로 메모리 해체,할당이 가능하다. 언매지니드 언어는 개발자가 메모리 제어를 주도 할 수 있어서 역량에 따른 최적의 성능을 확보 할 수 있지만 그 반대의 경우 최적의 치명적 오류를 발생 시킬 수도 있다. <br />
매니지드 언어:
자바스크립트 같은 매니지드 언어는 메모리의 해체,할당을 언어 차원에서 담당하고 개발자의 직접적인 제어를 허용하지 않는다. 더이상 사용하지 않는 메모리는 가비지 콜렉터가 수행하며 개발자가 의존하는 부분이 상대적으로 작아져 어느 정도 일정한 생산량을 확보 할 수 있지만, 어느 정도의 손실 역시 감수 할 수 밖에 없다.</p>
</blockquote>
<h3 id="📄-reference">📄 Reference</h3>
<h4 id="자바스크립트-deep-dive">자바스크립트 deep dive</h4>
<h4 id="wikibooks"><a href="https://github.com/wikibook/mjs/blob/master/04.md">wikibooks</a></h4>